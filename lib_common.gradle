// GEOTrac Android library build script helpers

enum BuildType {
    DEVELOPMENT("dev"), BETA("beta"), RELEASE("release")

    BuildType(String displayName) { this.displayName = displayName }
    private final String displayName;

    public String toString() { return displayName }

    public static fromBranch(String branch) {
        // We use git flow - http://nvie.com/posts/a-successful-git-branching-model/
        // The defaults use release/, hotfix/, etc instead of release- and hotfix- mentioned above
        if (branch.equals("master")) {
            //Our only releases are on master
            return BuildType.RELEASE
        } else if (branch.startsWith("release/") || branch.startsWith("hotfix/")) {
            //Both releases and hotfixes are prereleases - a new version that will show up as a full release later
            return BuildType.BETA
        } else {
            return BuildType.DEVELOPMENT
        }
    }
}

project.ext.serverPropertiesFile = file('version.properties')

Boolean isBuildServer() {
    //Only the server should actually define this file
    return project.serverPropertiesFile.exists()
}

//The build server writes some data to a file that we can make use of
String getBuildServerProperty(String key) {
    if (!project.serverPropertiesFile.canRead()) {
        throw new GradleException("Could not read build server properties file " + project.serverPropertiesFile.toString())
    }

    def Properties serverProperties = new Properties()

    // Load the properties, and then release the file handle
    def versionFileStream = new FileInputStream(project.serverPropertiesFile)
    serverProperties.load(versionFileStream)
    versionFileStream.close()

    //Get rid of empty space, and if we end up with nothing left, that's a problem!
    def value = serverProperties[key]?.trim()
    if (value == "") throw new GradleException(key + " is defined, but has an empty string!")

    return value
}

String getProperty(String key, Closure<String> funcToGetDefault) {
    def serverValue = isBuildServer() ? getBuildServerProperty(key) : null

    //Using a closure allows for lazy evaluation, in case the function doesn't work on the build server
    //This is true for anything that tries to use git, for example, since the build server uses only the working directory
    return serverValue ?: funcToGetDefault.call()
}

String getGitBranch() {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', '--abbrev-ref', 'HEAD'
        standardOutput = stdout
    }

    //Output will look like: master
    return stdout.toString().trim()
}

ext.isReleaseMode = BuildType.fromBranch(getProperty('git.branch', { getGitBranch() })) == BuildType.RELEASE

def determineVersion(String baseVersion) {
    return isReleaseMode ? baseVersion : baseVersion + "-SNAPSHOT"
}

def getPublishUrl() {
    return "http://packages.geotracinternational.com/nexus/repository/maven-" + (isReleaseMode ? "releases" : "snapshots")
}

// Export methods by turning them into closures
ext {
    determineVersion = this.&determineVersion
    getPublishUrl = this.&getPublishUrl
}