// GEOTrac Android library build script helpers

enum BuildType {
    DEVELOPMENT("dev"), BETA("beta"), RELEASE("release")

    BuildType(String displayName) { this.displayName = displayName }
    private final String displayName;

    public String toString() { return displayName }

    public static fromBranch(String branch) {
        // We use git flow - http://nvie.com/posts/a-successful-git-branching-model/
        // The defaults use release/, hotfix/, etc instead of release- and hotfix- mentioned above
        if (branch.equals("master")) {
            //Our only releases are on master
            return BuildType.RELEASE
        } else if (branch.startsWith("release/") || branch.startsWith("hotfix/")) {
            //Both releases and hotfixes are prereleases - a new version that will show up as a full release later
            return BuildType.BETA
        } else {
            return BuildType.DEVELOPMENT
        }
    }
}

class Version {
    int major
    int minor
    int revision

    public Version(String semanticVersion) {
        def tokens = semanticVersion.split("\\.")

        if (tokens.length < 2 || tokens.length > 3) {
            throw new GradleException("Version " + semanticVersion + " does not appear to be semantic - found " + tokens.length.toString() + " version numbers")
        }

        major = Integer.parseInt(tokens[0])
        minor = Integer.parseInt(tokens[1])

        //The revision is entirely optional
        revision = tokens.length > 2 ? Integer.parseInt(tokens[2]) : 0
    }

    public String toString() {
        return major + "." + minor + "." + revision;
    }
}

project.ext.serverPropertiesFile = file('version.properties')

Boolean isBuildServer() {
    //Only the server should actually define this file
    return project.serverPropertiesFile.exists()
}

//The build server writes some data to a file that we can make use of
String getBuildServerProperty(String key) {
    if (!project.serverPropertiesFile.canRead()) {
        throw new GradleException("Could not read build server properties file " + project.serverPropertiesFile.toString())
    }

    def Properties serverProperties = new Properties()

    // Load the properties, and then release the file handle
    def versionFileStream = new FileInputStream(project.serverPropertiesFile)
    serverProperties.load(versionFileStream)
    versionFileStream.close()

    //Get rid of empty space, and if we end up with nothing left, that's a problem!
    def value = serverProperties[key]?.trim()
    if (value == "") throw new GradleException(key + " is defined, but has an empty string!")

    return value
}

String getProperty(String key, Closure<String> funcToGetDefault) {
    def serverValue = isBuildServer() ? getBuildServerProperty(key) : null

    //Using a closure allows for lazy evaluation, in case the function doesn't work on the build server
    //This is true for anything that tries to use git, for example, since the build server uses only the working directory
    return serverValue ?: funcToGetDefault.call()
}

String getGitBranch() {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', '--abbrev-ref', 'HEAD'
        standardOutput = stdout
    }

    //Output will look like: master
    return stdout.toString().trim()
}

//Returns a branch key, like GAT-123, if available; otherwise, returns null
String getBranchKey(String branch) {
    //Strip off any directories (e.g. feature/), taking the last string after a slash
    def branchName = branch.split("/").last()

    //Look at the first two hyphenated parts for a key, checking if the first part is all letters and the second part is all numbers
    def hyphenatedParts = branchName.split("-")

    if (hyphenatedParts.length >= 2 && hyphenatedParts[0] ==~ /[a-zA-Z]+/ && hyphenatedParts[1] ==~ /[0-9]+/) {
        return hyphenatedParts[0].toUpperCase() + "-" + hyphenatedParts[1]
    }

    return null
}

def assertNonNull(def value, String errorMessage) {
    if (value == null) throw new GradleException(errorMessage)

    value
}

ext.isReleaseMode = BuildType.fromBranch(getProperty('git.branch', {
    getGitBranch()
})) == BuildType.RELEASE

def determineVersion(String baseVersion) {

    return baseVersion + "-SNAPSHOT"
}

def getLibraryVersion(String semanticVersion) {
    def branch = getProperty('git.branch', { getGitBranch() })
    def version = new Version(semanticVersion)

    switch (BuildType.fromBranch(branch)) {
        case BuildType.RELEASE:
            return version.toString()
        case BuildType.BETA:
            return version.toString() + "-SNAPSHOT"
        case BuildType.DEVELOPMENT:
            switch (branch) {
                case "develop":
                    return version.major + ".x-" + branch + "-SNAPSHOT"
                default:
                    return assertNonNull(getBranchKey(branch), "Development branches must begin with a JIRA key!") + "-SNAPSHOT"
            }
    }
}

def getPublishUrl() {
    return "http://packages.geotracinternational.com/nexus/repository/maven-" + (isReleaseMode ? "releases" : "snapshots")
}

// Export methods by turning them into closures
ext {
    determineVersion = this.&determineVersion
    getPublishUrl = this.&getPublishUrl
    getLibraryVersion = this.&getLibraryVersion
}