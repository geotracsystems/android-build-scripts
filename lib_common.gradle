// GEOTrac Android library build script helpers

enum BuildType {
    DEVELOPMENT("dev"), BETA("beta"), RELEASE("release")

    BuildType(String displayName) { this.displayName = displayName }
    private final String displayName;

    public String toString() { return displayName }

    public static fromBranch(String branch) {
        // We use git flow - http://nvie.com/posts/a-successful-git-branching-model/
        // The defaults use release/, hotfix/, etc instead of release- and hotfix- mentioned above
        if (branch.equals("master")) {
            //Our only releases are on master
            return BuildType.RELEASE
        } else if (branch.startsWith("release/") || branch.startsWith("hotfix/")) {
            //Both releases and hotfixes are prereleases - a new version that will show up as a full release later
            return BuildType.BETA
        } else {
            return BuildType.DEVELOPMENT
        }
    }
}

abstract class LibraryVersionFormatter {
    public static VersionFormatter fromBranch(String branch) {
        switch (BuildType.fromBranch(branch)) {
            case BuildType.RELEASE:
                return new ReleaseVersionFormatter()
            case BuildType.BETA:
                return new BetaVersionFormatter()
            case BuildType.DEVELOPMENT:
                switch (branch) {
                    case "HEAD":
                        return new HeadVersionFormatter()
                    case "develop":
                        return new DevelopVersionFormatter();
                    default:
                        return new FeatureVersionFormatter(branch);
                }
        }

        //If we got here, something went terribly wrong
        throw new GradleException("Unable to determine the version formatter for " + branch);
    }
}

abstract class DependencyVersionFormatter {
    public static VersionFormatter fromBranch(String branch) {
        switch (BuildType.fromBranch(branch)) {
            case BuildType.RELEASE:
            case BuildType.BETA:
                return new ReleaseVersionFormatter()
            case BuildType.DEVELOPMENT:
                return new DevelopVersionFormatter();
        }

        //If we got here, something went terribly wrong
        throw new GradleException("Unable to determine the version formatter for " + branch);
    }
}

interface VersionFormatter {
    String print(LibraryVersion version)
}

class HeadVersionFormatter implements VersionFormatter {

    @Override
    String print(LibraryVersion version) {
        return version.major + getGitHash()
    }
}

class DevelopVersionFormatter implements VersionFormatter {
    public String print(LibraryVersion version) {
        version.major + ".x-develop-SNAPSHOT"
    }
}

class FeatureVersionFormatter implements VersionFormatter {
    String jiraKey

    public FeatureVersionFormatter(String branch) {
        jiraKey = GitBranch.getJiraKey(branch)
    }

    public String print(LibraryVersion version) {
        //We don't actually use the version - feature branches are in complete flux
        jiraKey + "-SNAPSHOT"
    }
}

class BetaVersionFormatter implements VersionFormatter {
    public String print(LibraryVersion version) {
        version.toString() + "-SNAPSHOT"
    }
}

class ReleaseVersionFormatter implements VersionFormatter {
    public String print(LibraryVersion version) {
        version.toString()
    }
}

class LibraryVersion {
    int major
    int minor
    int revision

    public LibraryVersion(String semanticVersion) {
        if (!isSemanticVersion(semanticVersion)) {
            throw new GradleException("LibraryVersion " + semanticVersion + " does not appear to be semantic")
        }

        def tokens = semanticVersion.split("\\.")
        major = tokens[0] as int
        minor = tokens[1] as int

        //The revision is entirely optional
        revision = tokens.length > 2 ? tokens[2] as int : 0
    }

    boolean isSemanticVersion(String version) {
        //We expect to get versions like <major>.<minor> or <major>.<minor>.<revision>, and nothing else
        version ==~ /[0-9]+\.[0-9]+\.?[0-9]*/
    }

    public String toString() {
        return major + "." + minor + "." + revision;
    }
}

def getServerPropertiesFile() {
    def rootProject = project;
    while (rootProject.parent) {
        rootProject = rootProject.parent
    }

    rootProject.file('version.properties')
}

boolean isBuildServer() {
    //Only the server should actually define this file
    return getServerPropertiesFile().exists()
}

//The build server writes some data to a file that we can make use of
String getBuildServerProperty(String key) {
    if (!getServerPropertiesFile().canRead()) {
        throw new GradleException("Could not read build server properties file " + getServerPropertiesFile().toString())
    }

    def Properties serverProperties = new Properties()

    // Load the properties, and then release the file handle
    def versionFileStream = new FileInputStream(getServerPropertiesFile())
    serverProperties.load(versionFileStream)
    versionFileStream.close()

    //Get rid of empty space, and if we end up with nothing left, that's a problem!
    def value = serverProperties[key]?.trim()
    if (value == "") throw new GradleException(key + " is defined, but has an empty string!")

    return value
}

String getProperty(String key, Closure<String> funcToGetDefault) {
    def serverValue = isBuildServer() ? getBuildServerProperty(key) : null

    //Using a closure allows for lazy evaluation, in case the function doesn't work on the build server
    //This is true for anything that tries to use git, for example, since the build server uses only the working directory
    return serverValue ?: funcToGetDefault.call()
}

Closure<String> getGitBranch() {
    return {
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'rev-parse', '--abbrev-ref', 'HEAD'
            standardOutput = stdout
        }

        //Output will look like: master
        return stdout.toString().trim()
    }
}

class GitBranch {
    //Returns a branch key, like GAT-123, if available; otherwise, returns null
    public static String getJiraKey(String branch) {
        //Strip off any directories (e.g. feature/), taking the last string after a slash
        def branchName = branch.split("/").last()

        //Look at the first two hyphenated parts for a key, checking if the first part is all letters and the second part is all numbers
        def hyphenatedParts = branchName.split("-")

        if (hyphenatedParts.length < 2 || !(hyphenatedParts[0] ==~ /[a-zA-Z]+/ && hyphenatedParts[1] ==~ /[0-9]+/)) {
            throw new GradleException("Feature branch " + branch + " does not begin with a JIRA key!")
        }

        return hyphenatedParts[0].toUpperCase() + "-" + hyphenatedParts[1]
    }
}

class Assert {
    public static def nonNull(def value, String errorMessage) {
        if (value == null) throw new GradleException(errorMessage)

        value
    }
}

String currentBranch() {
    getProperty('git.branch', getGitBranch())
}

boolean isReleaseMode() {
    BuildType.fromBranch(currentBranch()) == BuildType.RELEASE
}

@Deprecated
//Required for old builds to continue working
def determineVersion(String baseVersion) {
    return baseVersion + "-SNAPSHOT"
}

def getLibraryVersion(String semanticVersion) {
    return LibraryVersionFormatter.fromBranch(currentBranch()).print(new LibraryVersion(semanticVersion))
}

def getDependencyVersion(String semanticVersion) {
    return DependencyVersionFormatter.fromBranch(currentBranch()).print(new LibraryVersion(semanticVersion))
}

def getPublishUrl() {
    return "http://packages.geotracinternational.com/nexus/repository/maven-" + (isReleaseMode() ? "releases" : "snapshots")
}

String getGitHash() {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', 'HEAD'
        standardOutput = stdout
    }

    //Output will look like: cfd998043fe86f3f1f2320512d6aabb51bfb5059
    return stdout.toString().trim()
}

// Export methods by turning them into closures
ext {
    isBuildServer = this.&isBuildServer
    determineVersion = this.&determineVersion
    getPublishUrl = this.&getPublishUrl
    getLibraryVersion = this.&getLibraryVersion
    getDependencyVersion = this.&getDependencyVersion
}