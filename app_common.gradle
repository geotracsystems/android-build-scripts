// GEOTrac Android build script helpers

project.ext.serverPropertiesFile = file('version.properties')

Boolean isBuildServer()
{
    return project.serverPropertiesFile.exists()
}

def getGitHash()
{
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', 'HEAD'
        standardOutput = stdout
    }

    return stdout.toString().trim()
}

def getGitBranch()
{
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', '--abbrev-ref', 'HEAD'
        standardOutput = stdout
    }

    return stdout.toString().trim()
}

def getGitTag()
{
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'describe', '--tag'
        standardOutput = stdout

        // Ignore errors
        errorOutput = new ByteArrayOutputStream()
        ignoreExitValue true
    }

    return stdout.toString().trim()
}

def getGitDirty()
{
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'status', '-s'
        standardOutput = stdout
    }

    return !stdout.toString().trim().isEmpty()
}

def determineBuildType(String branch)
{
    // We use git flow - http://nvie.com/posts/a-successful-git-branching-model/
    // The defaults use release/, hotfix/, etc instead of release- and hotfix- mentioned above
    if(branch.equals("master"))
    {
        //Our only releases are on master
        return "release"
    }
    else if(branch.startsWith("release/") || branch.startsWith("hotfix/"))
    {
        //Both releases and hotfixes are prereleases - a new version that will show up as a full release later
        return "prerelease"
    }
    else
    {
        return "dev"
    }
}

def generateVersionName(String version, String commitHash, String buildType, Boolean isDirty)
{
    def versionName = version + "-" + buildType

    versionName += "-" + commitHash.substring(0, 7)

    return isDirty ? versionName + "-dirty" : versionName
}

// Unused second parameter is because of old scripts using beta numbers
def getVersionName(String version, int unusedBetaNumber=0)
{
    if(!isBuildServer())
    {
        def buildType = determineBuildType(getGitBranch());

        return generateVersionName(version, getGitHash(), buildType, getGitDirty())
    }

    if(project.serverPropertiesFile.canRead())
    {
        def Properties versionProps = new Properties()

        // Load the properties, and then release the file handle
        def versionFileStream = new FileInputStream(project.serverPropertiesFile)
        versionProps.load(versionFileStream)
        versionFileStream.close()

        def hash = versionProps['git.commit'].toString().trim()
        def buildType = versionProps['build.type'].toString().trim()

        return generateVersionName(version, hash, buildType, false)
    }
    else
    {
        throw new GradleException("Could not read version.properties!")
    }
}

def getVersionCode(int defaultCode)
{
    if(!isBuildServer())
    {
        return defaultCode
    }

    if(project.serverPropertiesFile.canRead())
    {
        def Properties versionProps = new Properties()

        // Load the properties, and then release the file handle
        def versionFileStream = new FileInputStream(project.serverPropertiesFile)
        versionProps.load(versionFileStream)
        versionFileStream.close()

        def String buildNumber = versionProps['build.number']

        return (buildNumber == null || buildNumber == "") ? defaultCode : Integer.parseInt(buildNumber.trim())
    }
    else
    {
        throw new GradleException("Could not read version.properties!")
    }
}

// Export methods by turning them into closures
ext {
    getVersionCode = this.&getVersionCode
    getVersionName = this.&getVersionName
    getGitHash = this.&getGitHash
    getGitBranch = this.&getGitBranch
    getGitTag = this.&getGitTag
}
