// GEOTrac Android build script helpers

project.ext.serverPropertiesFile = file('version.properties')

Boolean isBuildServer()
{
    return project.serverPropertiesFile.exists()
}

//The build server writes some data to a file that we can make use of
String getBuildServerProperty(String key)
{
    if(!project.serverPropertiesFile.canRead())
    {
        throw new GradleException("Could not read build server properties file " + project.serverPropertiesFile.toString())
    }

    def Properties serverProperties = new Properties()

    // Load the properties, and then release the file handle
    def versionFileStream = new FileInputStream(project.serverPropertiesFile)
    serverProperties.load(versionFileStream)
    versionFileStream.close()

    return serverProperties[key].trim()
}

String getProperty(String key, Closure<String> funcToGetDefault)
{
    if(!isBuildServer()) return funcToGetDefault.call();

    return getBuildServerProperty(key)
}

String getGitHash()
{
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', 'HEAD'
        standardOutput = stdout
    }

    return stdout.toString().trim()
}

String getGitBranch()
{
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', '--abbrev-ref', 'HEAD'
        standardOutput = stdout
    }

    return stdout.toString().trim()
}

String getGitTag()
{
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'describe', '--tag'
        standardOutput = stdout

        // Ignore errors
        errorOutput = new ByteArrayOutputStream()
        ignoreExitValue true
    }

    return stdout.toString().trim()
}

Boolean isGitDirty()
{
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'status', '-s'
        standardOutput = stdout
    }

    return !stdout.toString().trim().isEmpty()
}

String determineBuildType(String branch)
{
    // We use git flow - http://nvie.com/posts/a-successful-git-branching-model/
    // The defaults use release/, hotfix/, etc instead of release- and hotfix- mentioned above
    if(branch.equals("master"))
    {
        //Our only releases are on master
        return "release"
    }
    else if(branch.startsWith("release/") || branch.startsWith("hotfix/"))
    {
        //Both releases and hotfixes are prereleases - a new version that will show up as a full release later
        return "prerelease"
    }
    else
    {
        return "dev"
    }
}

String generateVersionName(String version, String commitHash, String buildType, Boolean isDirty)
{
    def versionName = version + "-" + buildType

    versionName += "-" + commitHash.substring(0, 7)

    return isDirty ? versionName + "-dirty" : versionName
}

// Unused second parameter is because of old scripts using beta numbers
String getVersionName(String version, int unusedBetaNumber=0)
{
    def hash = getProperty('git.commit', { getGitHash() })
    def buildType = determineBuildType(getProperty('git.branch', { getGitBranch() }))

    return generateVersionName(version, hash, buildType, isBuildServer() ? false : isGitDirty())
}

int getVersionCode(int defaultCode)
{
    def buildNumber = getProperty('build.number', { defaultCode })

    return (buildNumber == null || buildNumber == "") ? defaultCode : Integer.parseInt(buildNumber.trim())
}

// Export methods by turning them into closures
ext {
    getVersionCode = this.&getVersionCode
    getVersionName = this.&getVersionName
    getGitHash = this.&getGitHash
    getGitBranch = this.&getGitBranch
    getGitTag = this.&getGitTag
}
