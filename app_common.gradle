// GEOTrac Android build script helpers

enum BuildType {
    DEVELOPMENT("dev"), BETA("beta"), RELEASE("release")

    BuildType(String displayName) {
        this.displayName = displayName
    }
    private final String displayName;

    public String toString() {
        return displayName
    }

    public static fromBranch(String branch) {
        // We use git flow - http://nvie.com/posts/a-successful-git-branching-model/
        // The defaults use release/, hotfix/, etc instead of release- and hotfix- mentioned above
        if (branch.equals("master")) {
            //Our only releases are on master
            return BuildType.RELEASE
        } else if (branch.startsWith("release/") || branch.startsWith("hotfix/")) {
            //Both releases and hotfixes are prereleases - a new version that will show up as a full release later
            return BuildType.BETA
        } else {
            return BuildType.DEVELOPMENT
        }
    }
}

def getServerPropertiesFile() {
    def rootProject = project;
    while (rootProject.parent) {
        rootProject = rootProject.parent
    }

    rootProject.file('version.properties')
}

boolean isBuildServer() {
    //Only the server should actually define this file
    return getServerPropertiesFile().exists()
}

//The build server writes some data to a file that we can make use of
String getBuildServerProperty(String key) {
    if (!getServerPropertiesFile().canRead()) {
        throw new GradleException("Could not read build server properties file " + getServerPropertiesFile().toString())
    }

    def Properties serverProperties = new Properties()

    // Load the properties, and then release the file handle
    def versionFileStream = new FileInputStream(getServerPropertiesFile())
    serverProperties.load(versionFileStream)
    versionFileStream.close()

    //Get rid of empty space, and if we end up with nothing left, that's a problem!
    def value = serverProperties[key]?.trim()
    if (value == "") throw new GradleException(key + " is defined, but has an empty string!")

    return value
}

String getProperty(String key, Closure<String> funcToGetDefault) {
    def serverValue = isBuildServer() ? getBuildServerProperty(key) : null

    //Using a closure allows for lazy evaluation, in case the function doesn't work on the build server
    //This is true for anything that tries to use git, for example, since the build server uses only the working directory
    return serverValue ?: funcToGetDefault.call()
}

String getGitHash() {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', 'HEAD'
        standardOutput = stdout
    }

    //Output will look like: cfd998043fe86f3f1f2320512d6aabb51bfb5059
    return stdout.toString().trim()
}

String getGitBranch() {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', '--abbrev-ref', 'HEAD'
        standardOutput = stdout
    }

    //Output will look like: master
    return stdout.toString().trim()
}

String getGitTag() {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'describe', '--tag', '--exact-match'
        standardOutput = stdout

        // Ignore errors
        errorOutput = new ByteArrayOutputStream()
        ignoreExitValue true
    }

    //Output will look like: 1.5.1
    //String will be empty if there is no tag
    return stdout.toString().trim()
}

boolean isGitDirty() {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'status', '-s'
        standardOutput = stdout
    }

    //Output is a list of files and whether they are added, removed, or modified
    //There is no output if nothing is modified
    return !stdout.toString().trim().isEmpty()
}

String generateVersionName(String version, String commitHash, BuildType buildType, Boolean isDirty) {
    def versionName = version

    //Releases should produce a clean, recognizable output like 1.0
    //Other builds should indicate what they are and where they came from, like 1.0-beta-1234aef
    if (buildType != BuildType.RELEASE) {
        versionName += "-" + buildType.toString() + "-" + commitHash.substring(0, 7)
    }

    return isDirty ? versionName + "-dirty" : versionName
}

// Unused second parameter is because of old scripts using beta numbers
String getVersionName(String version, int unusedBetaNumber = 0) {
    def hash = getProperty('git.commit', { getGitHash() })
    def buildType = BuildType.fromBranch(getProperty('git.branch', { getGitBranch() }))

    return generateVersionName(version, hash, buildType, isBuildServer() ? false : isGitDirty())
}

int getVersionCode(int defaultCode) {
    return Integer.parseInt(getProperty('build.number', { defaultCode }))
}

// Export methods by turning them into closures
ext {
    getVersionCode = this.&getVersionCode
    getVersionName = this.&getVersionName
    getGitHash = this.&getGitHash
    getGitBranch = this.&getGitBranch
    getGitTag = this.&getGitTag
}
